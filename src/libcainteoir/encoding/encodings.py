#!/usr/bin/python

# Copyright (C) 2011 Reece H. Dunn
#
# This file is part of cainteoir-engine.
#
# cainteoir-engine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cainteoir-engine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cainteoir-engine.  If not, see <http://www.gnu.org/licenses/>.


import os
import sys

def utf8(x):
	return unichr(int(x.replace('U+', '').replace('0x', ''), 16)).encode('utf-8')

def u(x):
	c = unichr(int(x.replace('U+', '').replace('0x', ''), 16)).encode('utf-8')
	if c == '"' or c == '\'':
		return '\\%s' % c
	return repr(c).replace('\'', '')

def read_mnemonics(filename):
	mnemonics = {'??': None}
	with open(filename) as f:
		for line in f:
			data = line.split()
			if len(data) == 0 or data[0].startswith('#'):
				pass
			elif data[0] in mnemonics.keys():
				raise Exception('Duplicate mnemonic "%s"' % data[0])
			else:
				mnemonics[data[0]] = data[1]
	return mnemonics

mnemonics = read_mnemonics(os.path.join(sys.argv[1], 'mnemonics.lst'))

def read_encoding(filename):
	encoding = {'alias': [], 'codepage': [], 'data': []}
	encoding_format = 'rtf1345'
	with open(filename) as f:
		for line in f:
			data = line.split()
			if len(data) == 0:
				pass
			elif data[0].startswith('&'):
				name = data[0].replace('&', '')
				value = ' '.join(data[1:])
				if name == 'alias' or name == 'codepage':
					encoding[name].append(value.lower())
				elif name == 'charset':
					encoding['alias'].append(value.lower())
					encoding[name] = value
				elif name == 'format':
					encoding_format = value
				else:
					encoding[name] = value
			elif encoding_format == '3-column':
				if data[1] == '#UNDEFINED':
					encoding['data'].append(None)
				else:
					encoding['data'].append(data[1])
			else:
				encoding['data'].extend([mnemonics[c] for c in data])
	return encoding

encodings = {}
names = {}
codepages = {}

for encoding in os.listdir(sys.argv[1]):
	if encoding.endswith('.txt'):
		data = read_encoding(os.path.join(sys.argv[1], encoding))
		encodings[data['name']] = data
		for name in data['alias']:
			names[name] = data['name']
		for codepage in data['codepage']:
			codepages[int(codepage)] = data['name']

print """// THIS IS AN AUTOMATICALLY GENERATED FILE'
// generated by encodings.py'

struct encoding_t
{
	const char * name;
	const char ** table;
};

struct codepage_t
{
	int codepage;
	const char ** table;
};"""

for name, data in sorted(encodings.items()):
	print
	print 'static const char * encoding_%s[256] = { // %s : %s' % (name, data['charset'], data['source'])
	for c in data['data']:
		if c:
			print '\t"%s",' % u(c)
		else:
			print '\tNULL,'
	for i in range(0, 256 - len(data['data'])):
		print '\tNULL,'
	print '};'

print
print 'static const encoding_t encodings[] = {'
for name, encoding in sorted(names.items()):
	print '\t{ "%s", encoding_%s },' % (name, encoding)
print '};'

print
print 'static const codepage_t codepages[] = {'
for codepage, encoding in sorted(codepages.items()):
	print '\t{ %d, encoding_%s },' % (codepage, encoding)
print '};'
